datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String        @id @default(cuid())
  email         String        @unique
  passwordHash  String
  name          String?
  phone         String?
  role          UserRole      @default(RENTER)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  spots         ParkingSpot[] @relation("UserSpots")
  bookings      Booking[]     @relation("UserBookings")
  notifications Notification[]
  pushTokens    PushToken[]
  ownedBlacklist  BlacklistEntry[] @relation("OwnerBlacklist")
  renterBlacklist BlacklistEntry[] @relation("RenterBlacklist")
  verificationRequests OwnerVerification[] @relation("OwnerVerificationOwner")
  reviewedVerifications OwnerVerification[] @relation("OwnerVerificationReviewer")
  depositTransactionsCreated DepositTransaction[] @relation("UserDepositTransactions")
  verificationDocumentsReviewed VerificationDocument[] @relation("VerificationDocumentReviewer")
  spotModerationDecisions SpotModerationLog[] @relation("SpotModerationReviewer")
  reviews       Review[]      @relation("RenterReviews")
  moderatedReviews Review[]  @relation("ModeratorReviews")
  favorites     Favorite[]
}

enum UserRole {
  RENTER
  OWNER
  ADMIN
}

model ParkingSpot {
  id                 String        @id @default(cuid())
  ownerId            String
  owner              User          @relation("UserSpots", fields: [ownerId], references: [id])

  status             SpotStatus    @default(DRAFT)
  title              String
  description        String
  pricePerHour       Int
  currency           String        @default("RUB")
  spotNumber         String?       // Номер парковочного места

  sizeL              Float
  sizeW              Float
  sizeH              Float
  covered            Boolean       @default(false)
  guarded            Boolean       @default(false)
  camera             Boolean       @default(false)
  evCharging         Boolean       @default(false)
  disabledAccessible Boolean       @default(false)
  wideEntrance       Boolean       @default(false)

  accessType         AccessType
  rules              String
  address            String
  geoLat             Float
  geoLng             Float

  instantApproval    Boolean       @default(false)

  // Политика отмены и ценообразование
  cancellationPolicy String        @default("MODERATE") // FLEXIBLE, MODERATE, STRICT
  cancellationDeadlineHours Int    @default(24) // За сколько часов можно отменить
  depositRequired    Boolean       @default(false)
  depositAmount      Int?          // Фиксированная сумма или процент от цены
  depositPercent     Int?          // Процент от стоимости (если depositAmount не указан)

  photos             SpotPhoto[]
  availability       AvailabilityRule[]
  blackouts          BookingBlock[]
  bookings           Booking[]
  moderationLogs     SpotModerationLog[]
  reviews            Review[]
  favorites          Favorite[]

  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  @@index([ownerId])
  @@index([geoLat, geoLng])
  @@index([pricePerHour])
  @@index([status])
}

enum SpotStatus {
  DRAFT
  PENDING_VERIFICATION
  PENDING_REVIEW
  AUTO_APPROVED
  AUTO_REJECTED
  APPROVED
  REJECTED
}

enum AccessType {
  PRIVATE_GATE
  STREET
  GARAGE
  YARD
  OTHER
}

model SpotPhoto {
  id        String       @id @default(cuid())
  spotId    String
  spot      ParkingSpot  @relation(fields: [spotId], references: [id])
  url       String
  sortOrder Int          @default(0)
}

model AvailabilityRule {
  id        String        @id @default(cuid())
  spotId    String
  spot      ParkingSpot   @relation(fields: [spotId], references: [id])
  type      AvailabilityType
  weekdays  Int[]         @default([])
  fromTime  Int?
  toTime    Int?
  from      DateTime?
  to        DateTime?
}

enum AvailabilityType {
  RECURRING
  SPECIFIC
}

model Booking {
  id               String        @id @default(cuid())
  spotId           String
  spot             ParkingSpot   @relation(fields: [spotId], references: [id])
  renterId         String
  renter           User          @relation("UserBookings", fields: [renterId], references: [id])

  startAt          DateTime
  endAt            DateTime
  status           BookingStatus @default(PENDING)

  totalPrice       Int
  commissionPct    Int           @default(10)
  commissionAmount Int           @default(0)
  ownerAmount      Int           @default(0)
  paymentId        String?
  depositAmount    Int           @default(0)
  depositStatus    DepositStatus @default(NOT_REQUIRED)
  penaltyAmount    Int           @default(0)
  penaltyReason    String?
  disputeOpenedAt  DateTime?
  disputeResolvedAt DateTime?
  disputeDeadline  DateTime?
  disputeEvidence  Json?

  // Геолокация и маршрут при бронировании
  renterLat        Float?
  renterLng        Float?
  routeDistance    Float?         // Расстояние до парковки (метры)
  routeDuration    Int?           // Время в пути (секунды)
  routePolyline    String?        // Полилиния маршрута (JSON)

  depositTransactions DepositTransaction[]
  review            Review?

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([spotId, startAt, endAt])
  @@index([renterId])
  @@index([status])
}

enum BookingStatus {
  PENDING
  APPROVED
  DECLINED
  CANCELLED
  PAID
}

enum DepositStatus {
  NOT_REQUIRED
  PENDING
  HELD
  PARTIALLY_RELEASED
  RELEASED
  FORFEITED
  FAILED
}

enum DepositTransactionType {
  HOLD
  RELEASE
  PARTIAL_RELEASE
  FORFEIT
  REFUND
  ADJUSTMENT
}

model DepositTransaction {
  id          String                  @id @default(cuid())
  bookingId   String
  booking     Booking                 @relation(fields: [bookingId], references: [id])
  type        DepositTransactionType
  amount      Int
  description String?
  createdAt   DateTime                @default(now())
  createdById String?
  createdBy   User?                   @relation("UserDepositTransactions", fields: [createdById], references: [id])

  @@index([bookingId])
  @@index([type])
}

model BookingBlock {
  id      String       @id @default(cuid())
  spotId  String
  spot    ParkingSpot  @relation(fields: [spotId], references: [id])
  from    DateTime
  to      DateTime
  reason  String?
}

model Notification {
  id        String            @id @default(cuid())
  userId    String
  user      User              @relation(fields: [userId], references: [id])
  type      NotificationType
  title     String
  body      String
  meta      Json?
  readAt    DateTime?
  createdAt DateTime          @default(now())
}

enum NotificationType {
  EMAIL
  PUSH
  INAPP
}

model PushToken {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  provider  String
  token     String
  createdAt DateTime @default(now())
}

model BlacklistEntry {
  id        String   @id @default(cuid())
  ownerId   String
  renterId  String
  reason    String?
  createdAt DateTime @default(now())

  owner     User     @relation("OwnerBlacklist", fields: [ownerId], references: [id])
  renter    User     @relation("RenterBlacklist", fields: [renterId], references: [id])

  @@index([ownerId])
  @@index([renterId])
}

enum VerificationStatus {
  DRAFT
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  NEEDS_MORE_INFO
}

enum VerificationDocumentType {
  IDENTITY_FRONT
  IDENTITY_BACK
  SELFIE
  PROOF_OF_ADDRESS
  OTHER
}

enum VerificationDocumentStatus {
  UPLOADED
  ACCEPTED
  REJECTED
}

model OwnerVerification {
  id            String             @id @default(cuid())
  ownerId       String
  owner         User               @relation("OwnerVerificationOwner", fields: [ownerId], references: [id])
  status        VerificationStatus @default(DRAFT)

  fullName      String
  documentType  VerificationDocumentType
  documentNumber String
  issuedBy      String?
  issuedAt      DateTime?

  submittedAt   DateTime?          @default(now())
  reviewedAt    DateTime?
  reviewerId    String?
  reviewer      User?              @relation("OwnerVerificationReviewer", fields: [reviewerId], references: [id])
  reviewerNotes String?
  provider      String?
  autoCheckScore Float?

  documents     VerificationDocument[]

  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  @@index([ownerId])
  @@index([status])
}

model VerificationDocument {
  id              String                     @id @default(cuid())
  verificationId  String
  verification    OwnerVerification          @relation(fields: [verificationId], references: [id])
  type            VerificationDocumentType   @default(IDENTITY_FRONT)
  status          VerificationDocumentStatus @default(UPLOADED)
  url             String
  metadata        Json?
  reviewerId      String?
  reviewer        User?                      @relation("VerificationDocumentReviewer", fields: [reviewerId], references: [id])
  reviewedAt      DateTime?

  createdAt       DateTime                   @default(now())
  updatedAt       DateTime                   @updatedAt

  @@index([verificationId])
  @@index([type])
}

enum SpotModerationDecision {
  AUTO_APPROVED
  AUTO_REJECTED
  AUTO_FLAGGED
  MANUAL_APPROVED
  MANUAL_REJECTED
}

model SpotModerationLog {
  id            String                @id @default(cuid())
  spotId        String
  spot          ParkingSpot           @relation(fields: [spotId], references: [id], onDelete: Cascade)
  decision      SpotModerationDecision
  statusBefore  SpotStatus
  statusAfter   SpotStatus
  notes         String?
  auto          Boolean               @default(false)
  reviewerId    String?
  reviewer      User?                 @relation("SpotModerationReviewer", fields: [reviewerId], references: [id])
  meta          Json?
  createdAt     DateTime              @default(now())

  @@index([spotId])
  @@index([decision])
  @@index([statusAfter])
}

// Рейтинги и отзывы
model Review {
  id            String   @id @default(cuid())
  spotId       String
  spot         ParkingSpot @relation(fields: [spotId], references: [id], onDelete: Cascade)
  renterId     String
  renter       User     @relation("RenterReviews", fields: [renterId], references: [id])
  bookingId    String?  @unique // Связь с бронированием (один отзыв на бронирование)
  booking      Booking? @relation(fields: [bookingId], references: [id])
  
  rating       Int      // 1-5 звезд
  title        String?  // Заголовок отзыва
  comment      String   // Текст отзыва
  photos       ReviewPhoto[]
  
  // Ответ владельца
  ownerResponse String?
  ownerResponseAt DateTime?
  
  // Модерация
  status       ReviewStatus @default(PENDING)
  moderatedAt  DateTime?
  moderatorId  String?
  moderator    User?    @relation("ModeratorReviews", fields: [moderatorId], references: [id])
  
  // Полезность отзыва
  helpfulCount Int      @default(0)
  reportedCount Int     @default(0)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([spotId])
  @@index([renterId])
  @@index([status])
  @@index([rating])
}

model ReviewPhoto {
  id        String  @id @default(cuid())
  reviewId  String
  review    Review  @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  url       String
  sortOrder Int     @default(0)
  
  @@index([reviewId])
}

enum ReviewStatus {
  PENDING      // На модерации
  APPROVED     // Одобрен
  REJECTED     // Отклонен
  HIDDEN       // Скрыт (после жалоб)
}

// Избранное
model Favorite {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  spotId    String
  spot      ParkingSpot @relation(fields: [spotId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  
  @@unique([userId, spotId]) // Один пользователь может добавить место только один раз
  @@index([userId])
  @@index([spotId])
}


